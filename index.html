<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TikTok Gift Climber (Canvas)</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      overflow: hidden;
      background: #020308;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      color: #fff;
    }
    #hint {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.55);
      font-size: 14px;
      z-index: 10;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      white-space: nowrap;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<div id="hint">Press <b>G</b> to add a climber · Drag with mouse to pan · Scroll to zoom</div>
<canvas id="game"></canvas>

<script>
  // -------------------------------------------------------
  // BASIC CANVAS SETUP (RETINA / HD)
  // -------------------------------------------------------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  let width = window.innerWidth;
  let height = window.innerHeight;
  let cameraY = 0;
  let cameraZoom = 1;

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  // -------------------------------------------------------
  // INPUT: PAN + ZOOM + GIFTS (G KEY)
  // -------------------------------------------------------
  let isDragging = false;
  let lastY = 0;

  canvas.addEventListener("mousedown", (e) => {
    isDragging = true;
    lastY = e.clientY;
  });

  window.addEventListener("mouseup", () => {
    isDragging = false;
  });

  window.addEventListener("mousemove", (e) => {
    if (!isDragging) return;
    const dy = e.clientY - lastY;
    lastY = e.clientY;
    cameraY += dy / cameraZoom;
  });

  window.addEventListener("wheel", (e) => {
    const zoomAmount = -e.deltaY * 0.001;
    const oldZoom = cameraZoom;
    cameraZoom = Math.min(Math.max(cameraZoom * (1 + zoomAmount), 0.4), 2.5);

    // Zoom towards mouse Y
    const mouseY = (e.clientY - height / 2) / oldZoom + cameraY;
    cameraY = mouseY - (e.clientY - height / 2) / cameraZoom;
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "g" || e.key === "G") {
      addClimber();
    }
  });

  // -------------------------------------------------------
  // BACKGROUND / MOUNTAIN DRAWING
  // -------------------------------------------------------
  function drawBackground() {
    const topColor = "#081632";
    const bottomColor = "#020308";

    const grad = ctx.createLinearGradient(0, 0, 0, height);
    grad.addColorStop(0, topColor);
    grad.addColorStop(1, bottomColor);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);

    // stars
    ctx.save();
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = "#ffffff";
    for (let i = 0; i < 120; i++) {
      const x = (i * 73) % width;
      const y = ((i * 211) % 200) + 10;
      ctx.fillRect(x, y, 1.2, 1.2);
    }
    ctx.restore();
  }

  function worldToScreen(x, y) {
    // world (0,0) is at center bottom-ish of screen
    const screenX = width / 2 + x * cameraZoom;
    const screenY = height - (y - cameraY) * cameraZoom;
    return { x: screenX, y: screenY };
  }

  function drawMountain() {
    ctx.save();
    ctx.beginPath();

    const baseY = -80;
    const peakY = 600;

    const leftBase = worldToScreen(-500, baseY);
    const rightBase = worldToScreen(500, baseY);
    const peak = worldToScreen(0, peakY);

    ctx.moveTo(leftBase.x, leftBase.y);
    // curved sides
    const steps = 40;
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const sideX = -400 + t * 800;
      const sideY =
        baseY +
        (peakY - baseY) * (1 - Math.pow(Math.abs((t - 0.5) * 2), 1.4));
      const p = worldToScreen(sideX, sideY);
      ctx.lineTo(p.x, p.y);
    }
    ctx.closePath();

    const grad = ctx.createLinearGradient(0, height, 0, 0);
    grad.addColorStop(0, "#1b2836");
    grad.addColorStop(0.35, "#354351");
    grad.addColorStop(0.9, "#8c9daf");
    ctx.fillStyle = grad;
    ctx.fill();

    // Snow cap
    ctx.beginPath();
    const snowStartY = peakY - 80;
    const snowBaseLeft = worldToScreen(-130, snowStartY);
    const snowBaseRight = worldToScreen(130, snowStartY);
    ctx.moveTo(snowBaseLeft.x, snowBaseLeft.y);
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const sx = -110 + t * 220;
      const sy =
        snowStartY +
        (peakY - snowStartY) * (1 - Math.pow(Math.abs((t - 0.5) * 2), 1.1));
      const p = worldToScreen(sx, sy);
      ctx.lineTo(p.x, p.y);
    }
    ctx.closePath();
    const snowGrad = ctx.createLinearGradient(0, height, 0, 0);
    snowGrad.addColorStop(0, "#edf4ff");
    snowGrad.addColorStop(1, "#ffffff");
    ctx.fillStyle = snowGrad;
    ctx.fill();

    // glowing sun
    const sunPos = worldToScreen(-260, 760);
    const sunRadius = 60 * cameraZoom;
    const sunGrad = ctx.createRadialGradient(
      sunPos.x,
      sunPos.y,
      0,
      sunPos.x,
      sunPos.y,
      sunRadius
    );
    sunGrad.addColorStop(0, "rgba(255,246,210,1)");
    sunGrad.addColorStop(1, "rgba(255,246,210,0)");
    ctx.fillStyle = sunGrad;
    ctx.fillRect(
      sunPos.x - sunRadius,
      sunPos.y - sunRadius,
      sunRadius * 2,
      sunRadius * 2
    );
    ctx.restore();
  }

  function drawPath() {
    ctx.save();
    ctx.lineWidth = 6 * cameraZoom;
    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";

    ctx.beginPath();
    let started = false;
    for (let i = 0; i <= 260; i++) {
      const t = i / 260;
      const y = 0 + t * 800;
      const amp = 120;
      const x =
        Math.sin(t * 5) * amp +
        Math.sin((t * 11 + 1) * 0.8) * (amp * 0.3) +
        Math.sin((t * 19 + 3) * 0.6) * (amp * 0.15);
      const p = worldToScreen(x, y);
      if (!started) {
        ctx.moveTo(p.x, p.y);
        started = true;
      } else {
        ctx.lineTo(p.x, p.y);
      }
    }
    ctx.stroke();

    ctx.restore();
  }

  // -------------------------------------------------------
  // CLIMBERS
  // -------------------------------------------------------
  const climbers = [];

  function pathXAtHeight(y) {
    const t = y / 800;
    const amp = 120;
    return (
      Math.sin(t * 5) * amp +
      Math.sin((t * 11 + 1) * 0.8) * (amp * 0.3) +
      Math.sin((t * 19 + 3) * 0.6) * (amp * 0.15)
    );
  }

  function addClimber() {
    const startHeight = Math.random() * 80;
    climbers.push({
      y: startHeight,
      speed: 18 + Math.random() * 18,
      bobOffset: Math.random() * Math.PI * 2,
      color: `hsl(${200 + Math.random() * 80}, 80%, 60%)`,
    });
  }

  // Start with 1 climber
  addClimber();

  function drawClimber(c, time) {
    const px = pathXAtHeight(c.y);
    const bob = Math.sin(time * 5 + c.bobOffset) * 2.6;
    const worldY = c.y + bob;
    const p = worldToScreen(px, worldY);

    const scale = 1.6 * cameraZoom;
    const bodyHeight = 28 * scale;
    const bodyWidth = 10 * scale;
    const legLength = 16 * scale;
    const armLength = 14 * scale;
    const headRadius = 6 * scale;

    ctx.save();

    // shadow
    const shadow = worldToScreen(px, c.y - 2);
    ctx.fillStyle = "rgba(0, 0, 0, 0.35)";
    ctx.beginPath();
    ctx.ellipse(
      shadow.x,
      shadow.y + 6 * scale,
      8 * scale,
      3 * scale,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // body
    ctx.fillStyle = c.color;
    ctx.fillRect(
      p.x - bodyWidth / 2,
      p.y - bodyHeight - headRadius * 1.4,
      bodyWidth,
      bodyHeight
    );

    // head
    ctx.beginPath();
    ctx.arc(
      p.x,
      p.y - bodyHeight - headRadius * 2.1,
      headRadius,
      0,
      Math.PI * 2
    );
    ctx.fillStyle = "#ffd7b0";
    ctx.fill();

    // backpack
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(
      p.x - bodyWidth / 2 - 3 * scale,
      p.y - bodyHeight - headRadius * 1.4 + 4 * scale,
      6 * scale,
      bodyHeight * 0.7
    );

    // walking animation
    const walk = Math.sin(time * 9 + c.bobOffset) * 0.9;

    // legs
    ctx.strokeStyle = "#222";
    ctx.lineWidth = 2.2 * scale;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(p.x, p.y - headRadius * 1.2);
    ctx.lineTo(
      p.x - 4 * scale + walk * 2 * scale,
      p.y - headRadius * 1.2 + legLength
    );
    ctx.moveTo(p.x, p.y - headRadius * 1.2);
    ctx.lineTo(
      p.x + 4 * scale - walk * 2 * scale,
      p.y - headRadius * 1.2 + legLength
    );
    ctx.stroke();

    // arms (reversed phase)
    ctx.beginPath();
    ctx.moveTo(p.x, p.y - bodyHeight - headRadius * 0.7);
    ctx.lineTo(
      p.x - 10 * scale - walk * 3 * scale,
      p.y - bodyHeight - headRadius * 0.7 + armLength
    );
    ctx.moveTo(p.x, p.y - bodyHeight - headRadius * 0.7);
    ctx.lineTo(
      p.x + 10 * scale + walk * 3 * scale,
      p.y - bodyHeight - headRadius * 0.7 + armLength
    );
    ctx.stroke();

    ctx.restore();
  }

  // -------------------------------------------------------
  // MAIN LOOP
  // -------------------------------------------------------
  let lastTime = performance.now();

  function loop(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    // update climbers
    const t = now / 1000;
    for (const c of climbers) {
      c.y += c.speed * dt;
      if (c.y > 780) {
        c.y = 780; // stop near summit
        c.speed = 0;
      }
    }

    drawBackground();
    drawMountain();
    drawPath();

    for (const c of climbers) {
      drawClimber(c, t);
    }

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
</script>
</body>
</html>
