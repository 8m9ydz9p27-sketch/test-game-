<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TikTok Gift Climber – 3D Style</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      overflow: hidden;
      background: #020308;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }
    #hint {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.55);
      font-size: 14px;
      z-index: 10;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      white-space: nowrap;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<div id="hint">
  Third-person 3D view · Press <b>G</b> to add a new climber
</div>
<canvas id="game"></canvas>

<script>
// =====================================================
// BASIC CANVAS / CAMERA SETUP
// =====================================================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let width = window.innerWidth;
let height = window.innerHeight;

function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resize);
resize();

// 3D vector helpers
function vec3(x=0,y=0,z=0){ return {x,y,z}; }
function add(a,b){ return vec3(a.x+b.x,a.y+b.y,a.z+b.z); }
function sub(a,b){ return vec3(a.x-b.x,a.y-b.y,a.z-b.z); }
function mul(a,s){ return vec3(a.x*s,a.y*s,a.z*s); }
function dot(a,b){ return a.x*b.x+a.y*b.y+a.z*b.z; }
function cross(a,b){ return vec3(
  a.y*b.z-a.z*b.y,
  a.z*b.x-a.x*b.z,
  a.x*b.y-a.y*b.x
); }
function length(v){ return Math.sqrt(dot(v,v)); }
function norm(v){
  const len = length(v)||1;
  return mul(v,1/len);
}

// camera
const FOV = 60 * Math.PI / 180;
const TAN_FOV = Math.tan(FOV/2);
let cameraPos = vec3(0,40,-120);
let cameraTarget = vec3(0,40,0);

// project world point to screen
function project(point){
  const forward = norm(sub(cameraTarget,cameraPos));
  const right = norm(cross(forward, vec3(0,1,0)));
  const up = cross(right, forward);

  const v = sub(point, cameraPos);
  const xCam = dot(v,right);
  const yCam = dot(v,up);
  const zCam = dot(v,forward);

  if (zCam <= 0.1) return null; // behind camera

  const aspect = width / height;
  const xNorm = (xCam / (zCam * TAN_FOV)) / aspect;
  const yNorm = (yCam / (zCam * TAN_FOV));

  const sx = (xNorm + 1) * 0.5 * width;
  const sy = (1 - yNorm) * 0.5 * height;
  const scale = 1 / zCam;
  return { x:sx, y:sy, z:zCam, scale };
}

// =====================================================
// PATH / MOUNTAIN GEOMETRY
// =====================================================
// t in [0,1] -> 3D position on spiral mountain path
const MOUNTAIN_HEIGHT = 800;    // world units
const BASE_RADIUS = 260;
const TOP_RADIUS = 70;
const PATH_TURNS = 5;           // spiral turns
const PATH_WIDTH = 32;          // world units

function pathPoint(t){
  const y = t * MOUNTAIN_HEIGHT;
  const radius = BASE_RADIUS + (TOP_RADIUS - BASE_RADIUS) * t;
  const theta = t * PATH_TURNS * Math.PI * 2;
  const x = Math.cos(theta) * radius;
  const z = Math.sin(theta) * radius;
  return vec3(x,y,z);
}

// Create path segment quad
function pathSegmentQuad(t0, t1){
  const p0 = pathPoint(t0);
  const p1 = pathPoint(t1);
  const tangent = norm(sub(p1,p0));
  const up = vec3(0,1,0);
  const side = norm(cross(up,tangent));
  const halfW = PATH_WIDTH * 0.5;
  const offset = mul(side, halfW);

  return [
    add(p0, offset),  // left0
    sub(p0, offset),  // right0
    sub(p1, offset),  // right1
    add(p1, offset)   // left1
  ];
}

// environment color by height
function envColors(t){
  if (t < 0.33){
    return {
      skyTop:   "#6ac6ff",
      skyBottom:"#024",
      fog:      "rgba(150,210,255,0.25)",
      path:     "#3c7040",
      side:     "#1d3c20"
    };
  } else if (t < 0.66){
    return {
      skyTop:   "#4b6fa8",
      skyBottom:"#020514",
      fog:      "rgba(150,170,210,0.35)",
      path:     "#7b6e54",
      side:     "#3e3326"
    };
  } else {
    return {
      skyTop:   "#e7f5ff",
      skyBottom:"#3c5c88",
      fog:      "rgba(255,255,255,0.5)",
      path:     "#f7f7fb",
      side:     "#9aa7c4"
    };
  }
}

// =====================================================
// CLIMBERS
// =====================================================
const climbers = [];
// 30 minutes (1800s) from bottom (t=0) to top (t=1)
const BASE_SPEED = 1 / (30 * 60); // progress per second

function addClimber(){
  climbers.push({
    t: 0,                         // progress 0..1
    speed: BASE_SPEED * (0.9 + Math.random()*0.3), // slight variation
    sideOffset: (Math.random()*2 - 1) * (PATH_WIDTH*0.25), // offset left/right
    color: `hsl(${200 + Math.random()*80},80%,60%)`,
    bobOffset: Math.random()*Math.PI*2
  });
}

// Start with one solo climber
addClimber();

window.addEventListener("keydown",(e)=>{
  if (e.key === "g" || e.key === "G"){
    addClimber();
  }
});

// =====================================================
// RENDER LOOP
// =====================================================
let lastTime = performance.now();

function drawBackground(avgT){
  const env = envColors(avgT);

  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,height);
  g.addColorStop(0, env.skyTop);
  g.addColorStop(1, env.skyBottom);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,width,height);

  // distant fog / horizon
  ctx.fillStyle = env.fog;
  ctx.fillRect(0,height*0.45,width,height*0.55);
}

function drawPath(mainT){
  const env = envColors(mainT);
  const segments = 120;
  const spanBefore = 0.10;
  const spanAfter  = 0.60;
  const tStart = Math.max(0, mainT - spanBefore);
  const tEnd   = Math.min(1, mainT + spanAfter);

  const dt = (tEnd - tStart) / segments;

  // draw from far to near (back-to-front)
  for (let i=segments-1; i>=0; i--){
    const t0 = tStart + dt*i;
    const t1 = t0 + dt;
    const quad = pathSegmentQuad(t0,t1);

    const proj = quad.map(p=>project(p));
    if (proj.some(p=>p===null)) continue;

    const avgZ = proj.reduce((a,p)=>a+p.z,0)/proj.length;
    let shade = 1 - Math.min(avgZ/450, 0.7);
    const pathCol = env.path;
    const sideCol = env.side;

    // simple darken
    function shadeColor(hex, factor){
      const c = parseInt(hex.slice(1),16);
      let r=(c>>16)&255, g=(c>>8)&255, b=c&255;
      r=Math.floor(r*factor); g=Math.floor(g*factor); b=Math.floor(b*factor);
      return `rgb(${r},${g},${b})`;
    }

    ctx.beginPath();
    ctx.moveTo(proj[0].x, proj[0].y);
    for(let j=1;j<4;j++) ctx.lineTo(proj[j].x, proj[j].y);
    ctx.closePath();
    ctx.fillStyle = shadeColor(pathCol, 0.5+shade*0.5);
    ctx.fill();

    // side shading line
    ctx.beginPath();
    ctx.moveTo(proj[1].x, proj[1].y);
    ctx.lineTo(proj[2].x, proj[2].y);
    ctx.lineWidth = 2;
    ctx.strokeStyle = shadeColor(sideCol, 0.4+shade*0.5);
    ctx.stroke();
  }
}

function drawClimber(one, time){
  const basePoint = pathPoint(one.t);
  const ahead = pathPoint(Math.min(1, one.t + 0.01));
  const tangent = norm(sub(ahead, basePoint));
  const up = vec3(0,1,0);
  const side = norm(cross(up,tangent));

  const position = add(basePoint, mul(side, one.sideOffset));

  // simple body proportions
  const p = project(position);
  if (!p) return;

  // scale with distance
  const baseHeight = 70; // pixels at reference distance
  const size = baseHeight * (1 / (p.z*0.04));
  const headR = size * 0.18;
  const bodyH = size * 0.45;
  const bodyW = size * 0.22;
  const legL  = size * 0.35;
  const armL  = size * 0.32;

  const bob = Math.sin(time*4 + one.bobOffset)* (size*0.035);

  const cx = p.x;
  const cy = p.y - size*0.3 + bob;

  ctx.save();

  // shadow
  const groundPos = project(vec3(position.x,0,position.z));
  if (groundPos){
    ctx.beginPath();
    ctx.ellipse(groundPos.x, groundPos.y, size*0.25, size*0.12, 0, 0, Math.PI*2);
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fill();
  }

  // legs
  ctx.strokeStyle = "#222";
  ctx.lineWidth = size*0.055;
  ctx.lineCap = "round";
  const walk = Math.sin(time*6 + one.bobOffset);

  ctx.beginPath();
  ctx.moveTo(cx, cy + bodyH*0.4);
  ctx.lineTo(cx - size*0.12 + walk*size*0.12,
             cy + bodyH*0.4 + legL);
  ctx.moveTo(cx, cy + bodyH*0.4);
  ctx.lineTo(cx + size*0.12 - walk*size*0.12,
             cy + bodyH*0.4 + legL);
  ctx.stroke();

  // body
  ctx.fillStyle = one.color;
  ctx.fillRect(
    cx - bodyW*0.5,
    cy - bodyH*0.5,
    bodyW,
    bodyH
  );

  // backpack
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.fillRect(
    cx - bodyW*0.5 - size*0.07,
    cy - bodyH*0.3,
    size*0.14,
    bodyH*0.7
  );

  // arms
  ctx.beginPath();
  ctx.moveTo(cx, cy - bodyH*0.2);
  ctx.lineTo(
    cx - size*0.18 - walk*size*0.18,
    cy - bodyH*0.2 + armL
  );
  ctx.moveTo(cx, cy - bodyH*0.2);
  ctx.lineTo(
    cx + size*0.18 + walk*size*0.18,
    cy - bodyH*0.2 + armL
  );
  ctx.stroke();

  // head
  ctx.beginPath();
  ctx.arc(cx, cy - bodyH*0.65, headR, 0, Math.PI*2);
  ctx.fillStyle = "#ffd7b0";
  ctx.fill();

  // simple face highlight
  ctx.beginPath();
  ctx.arc(cx+headR*0.25, cy - bodyH*0.65 - headR*0.1, headR*0.3, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.4)";
  ctx.fill();

  ctx.restore();
}

function updateCamera(mainClimber){
  const t = mainClimber.t;
  const center = pathPoint(t);
  const ahead = pathPoint(Math.min(1, t + 0.02));
  const tangent = norm(sub(ahead, center));
  const up = vec3(0,1,0);
  const side = norm(cross(tangent, up));

  const backDist = 180;
  const upDist = 70;

  cameraTarget = center;
  cameraPos = add(
    add(center, mul(tangent, -backDist)),
    mul(up, upDist)
  );

  // small side offset for cinematic angle
  cameraPos = add(cameraPos, mul(side, 40));
}

// main loop
function loop(now){
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  const time = now / 1000;

  // update climbers
  for (const c of climbers){
    c.t += c.speed * dt;
    if (c.t > 1) c.t = 1; // reached summit
  }

  const mainClimber = climbers[0];
  updateCamera(mainClimber);

  // average height for environment
  const avgT = Math.min(1, mainClimber.t + 0.1);

  drawBackground(avgT);
  drawPath(mainClimber.t);

  // draw climbers back-to-front
  const sorted = [...climbers].sort((a,b)=>{
    const pa = project(pathPoint(a.t));
    const pb = project(pathPoint(b.t));
    return (pb?.z||0) - (pa?.z||0);
  });
  for (const c of sorted){
    drawClimber(c, time);
  }

  // overlay: show progress %
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(15, height-40, 180, 26);
  ctx.fillStyle = "#fff";
  ctx.font = "12px system-ui, sans-serif";
  ctx.textBaseline = "middle";
  const pct = Math.round(mainClimber.t * 100);
  ctx.fillText(`Main climber: ${pct}% to summit`, 24, height-27);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
