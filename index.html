<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TikTok Gift Climber ‚Äì HD Mountain Run</title>
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      overflow: hidden;
      background: #020308;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }

    #hud {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      padding-top: 6px;
      z-index: 20;
      pointer-events: none;
    }

    #rules, #status, #eventMsg {
      max-width: 100%;
      padding: 10px 24px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.72);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      font-size: clamp(14px, 2.2vw, 18px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #rules {
      font-weight: 600;
    }

    #eventMsg {
      background: linear-gradient(90deg, rgba(255,90,90,0.9), rgba(255,160,80,0.9));
      display: none;
    }

    canvas { display: block; }

    /* subtle vignette to make it look more cinematic */
    #vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(circle at center, rgba(0,0,0,0) 55%, rgba(0,0,0,0.65) 100%);
      z-index: 5;
      mix-blend-mode: multiply;
    }
  </style>
</head>
<body>
<div id="hud">
  <div id="rules">
    üåπ Every Rose = +1 climber ¬∑ ‚è± 30-min climb ¬∑ üèÅ First to cross the finish wins ¬∑ üí∏ Money Gun = restart
  </div>
  <div id="status"></div>
  <div id="eventMsg"></div>
</div>
<canvas id="game"></canvas>
<div id="vignette"></div>

<script>
// =====================================================
// BASIC CANVAS / CAMERA SETUP
// =====================================================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const statusEl = document.getElementById("status");
const eventEl = document.getElementById("eventMsg");

let width = window.innerWidth;
let height = window.innerHeight;

function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resize);
resize();

// -----------------------------------------------------
// 3D vector helpers
// -----------------------------------------------------
function vec3(x=0,y=0,z=0){ return {x,y,z}; }
function add(a,b){ return vec3(a.x+b.x,a.y+b.y,a.z+b.z); }
function sub(a,b){ return vec3(a.x-b.x,a.y-b.y,a.z-b.z); }
function mul(a,s){ return vec3(a.x*s,a.y*s,a.z*s); }
function dot(a,b){ return a.x*b.x+a.y*b.y+a.z*b.z; }
function cross(a,b){ return vec3(
  a.y*b.z-a.z*b.y,
  a.z*b.x-a.x*b.z,
  a.x*b.y-a.y*b.x
); }
function length(v){ return Math.sqrt(dot(v,v)); }
function norm(v){
  const len = length(v)||1;
  return mul(v,1/len);
}

// -----------------------------------------------------
// Camera (over-the-shoulder)
// -----------------------------------------------------
const FOV = 60 * Math.PI / 180;
const TAN_FOV = Math.tan(FOV/2);
let cameraPos = vec3(0,40,-80);
let cameraTarget = vec3(0,40,0);

function project(point){
  const forward = norm(sub(cameraTarget,cameraPos));
  const right = norm(cross(forward, vec3(0,1,0)));
  const up = cross(right, forward);

  const v = sub(point, cameraPos);
  const xCam = dot(v,right);
  const yCam = dot(v,up);
  const zCam = dot(v,forward);

  if (zCam <= 0.1) return null;

  const aspect = width / height;
  const xNorm = (xCam / (zCam * TAN_FOV)) / aspect;
  const yNorm = (yCam / (zCam * TAN_FOV));

  const sx = (xNorm + 1) * 0.5 * width;
  const sy = (1 - yNorm) * 0.5 * height;
  const scale = 1 / zCam;
  return { x:sx, y:sy, z:zCam, scale };
}

// screen shake
let shakeTime = 0;
let shakeIntensity = 0;

// =====================================================
// PATH / MOUNTAIN GEOMETRY
// =====================================================
const MOUNTAIN_HEIGHT = 800;    // world units
const BASE_RADIUS = 260;
const TOP_RADIUS = 80;
const PATH_TURNS = 6;
const PATH_WIDTH = 32;

function pathPoint(t){
  const y = t * MOUNTAIN_HEIGHT;
  const radius = BASE_RADIUS + (TOP_RADIUS - BASE_RADIUS) * t;
  const theta = t * PATH_TURNS * Math.PI * 2;
  const sway = Math.sin(t * 10) * 8; // subtle uneven path
  const x = Math.cos(theta) * radius + sway;
  const z = Math.sin(theta) * radius;
  return vec3(x,y,z);
}

function pathSegmentQuad(t0, t1){
  const p0 = pathPoint(t0);
  const p1 = pathPoint(t1);
  const tangent = norm(sub(p1,p0));
  const up = vec3(0,1,0);
  const side = norm(cross(up,tangent));
  const halfW = PATH_WIDTH * 0.5;
  const offset = mul(side, halfW);

  return [
    add(p0, offset),
    sub(p0, offset),
    sub(p1, offset),
    add(p1, offset)
  ];
}

// environment color by height
function envColors(t){
  if (t < 0.33){
    return {
      skyTop:   "#7fd5ff",
      skyBottom:"#255a74",
      fog:      "rgba(160,220,255,0.28)",
      path:     "#5f9151",
      side:     "#274525",
      ground:   "#405f34",
      mountainNear:"#243546",
      mountainFar:"#132130",
      snow:"#eaf5ff"
    };
  } else if (t < 0.66){
    return {
      skyTop:   "#6684b3",
      skyBottom:"#172236",
      fog:      "rgba(170,185,220,0.3)",
      path:     "#837058",
      side:     "#4a3828",
      ground:   "#5d4a3a",
      mountainNear:"#353743",
      mountainFar:"#20212b",
      snow:"#e0e8f7"
    };
  } else {
    return {
      skyTop:   "#f2f7ff",
      skyBottom:"#47659c",
      fog:      "rgba(255,255,255,0.5)",
      path:     "#f8f8fc",
      side:     "#a8b5cf",
      ground:   "#dde4f1",
      mountainNear:"#b8c6da",
      mountainFar:"#9aacc7",
      snow:"#ffffff"
    };
  }
}

// =====================================================
// CLIMBERS & GAME LOGIC
// =====================================================
const climbers = [];
const BASE_SPEED = 1 / (30 * 60); // 30-minute climb
let gameTime = 0;
let nextHazardAt = 60;
let hazard = {
  active:false,
  type:null,
  startT:0,
  endT:0,
  timer:0,
  particles:[]
};
let gameOver = false;

function addClimber(spawnAtMain = false){
  let t;
  if (spawnAtMain && climbers.length > 0){
    // EXACTLY where the main climber is
    t = climbers[0].t;
  } else {
    t = 0;
  }

  // small sideways offset so you can see the crowd
  const sideOffset = (Math.random()*2 - 1) * (PATH_WIDTH*0.20);

  climbers.push({
    t,
    speed: BASE_SPEED * (0.9 + Math.random()*0.3),
    sideOffset,
    color: `hsl(${190 + Math.random()*100},84%,64%)`,
    bobOffset: Math.random()*Math.PI*2
  });
}

// start with one climber
addClimber(false);

window.addEventListener("keydown",(e)=>{
  if (e.key === "g" || e.key === "G"){
    addClimber(true);
  }
});

// =====================================================
// HAZARDS & PARTICLES
// =====================================================
const hazardTypes = ["fire","blizzard","rockfall"];

function spawnParticles(type){
  hazard.particles = [];
  const count = type === "rockfall" ? 80 : 190;

  for (let i=0;i<count;i++){
    if (type === "fire"){
      hazard.particles.push({
        x: width*0.5 + (Math.random()-0.5)*width*0.5,
        y: height*0.7 + Math.random()*height*0.25,
        vx: (Math.random()-0.5)*30,
        vy: -40 - Math.random()*45,
        life: 0.7 + Math.random()*0.9,
        maxLife: 0.7 + Math.random()*0.9,
        size: 8 + Math.random()*14,
        color1: "rgba(255,230,150,1)",
        color2: "rgba(255,90,40,0)"
      });
    } else if (type === "blizzard"){
      hazard.particles.push({
        x: Math.random()*width,
        y: Math.random()*height,
        vx: -70 - Math.random()*90,
        vy: 20 + Math.random()*40,
        life: 1.2 + Math.random()*1.5,
        maxLife: 1.2 + Math.random()*1.5,
        size: 2 + Math.random()*5,
        color1: "rgba(255,255,255,1)",
        color2: "rgba(255,255,255,0)"
      });
    } else if (type === "rockfall"){
      hazard.particles.push({
        x: Math.random()*width,
        y: -80 - Math.random()*180,
        vx: (Math.random()-0.5)*50,
        vy: 190 + Math.random()*160,
        life: 1.4 + Math.random()*0.6,
        maxLife: 1.4 + Math.random()*0.6,
        size: 10 + Math.random()*16,
        color1: "rgba(105,92,80,1)",
        color2: "rgba(45,38,32,0)"
      });
    }
  }
}

function triggerHazard(){
  if (climbers.length === 0) return;

  const main = climbers[0];
  const tCenter = Math.min(1, main.t + 0.03);

  hazard.active = true;
  hazard.type = hazardTypes[Math.floor(Math.random()*hazardTypes.length)];
  hazard.timer = 4;
  hazard.startT = Math.max(0, tCenter - 0.03);
  hazard.endT   = Math.min(1, tCenter + 0.03);
  spawnParticles(hazard.type);

  // screen shake
  if (hazard.type === "fire") shakeIntensity = 3;
  if (hazard.type === "blizzard") shakeIntensity = 2;
  if (hazard.type === "rockfall") shakeIntensity = 7;
  shakeTime = 0.7;

  // knock out ~50% of non-main climbers
  const survivors = [main];
  for (let i=1;i<climbers.length;i++){
    if (Math.random() < 0.5) continue;
    survivors.push(climbers[i]);
  }
  if (survivors.length === 0) survivors.push(main);
  climbers.length = 0;
  climbers.push(...survivors);

  // HUD message
  let msg = "";
  if (hazard.type === "fire") msg = "üî• Wildfire tears through the trail ‚Äì half the climbers are gone!";
  if (hazard.type === "blizzard") msg = "‚ùÑÔ∏è Whiteout blizzard ‚Äì only the toughest keep moving!";
  if (hazard.type === "rockfall") msg = "ü™® Rockfall! Massive boulders smash the path and wipe out half the group!";
  eventEl.textContent = msg;
  eventEl.style.display = "block";
}

function updateHazard(dt){
  if (hazard.active){
    hazard.timer -= dt;
    if (hazard.timer <= 0){
      hazard.active = false;
      eventEl.style.display = "none";
    }
  }
  if (!gameOver && gameTime >= nextHazardAt){
    triggerHazard();
    nextHazardAt += 60;
  }

  // particles
  for (let i=hazard.particles.length-1;i>=0;i--){
    const p = hazard.particles[i];
    p.life -= dt;
    if (p.life <= 0){
      hazard.particles.splice(i,1);
      continue;
    }
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    if (hazard.type === "blizzard"){
      if (p.x < -30) p.x = width + 30;
      if (p.y > height+30) p.y = -30;
    }
  }

  // shake decay
  if (shakeTime > 0){
    shakeTime -= dt;
    if (shakeTime <= 0) shakeIntensity = 0;
  }
}

// =====================================================
// BACKGROUND MOUNTAINS & GROUND
// =====================================================
function drawMountains(avgT){
  const env = envColors(avgT);

  // sky
  const g = ctx.createLinearGradient(0,0,0,height);
  g.addColorStop(0, env.skyTop);
  g.addColorStop(1, env.skyBottom);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,width,height);

  // haze strip
  ctx.fillStyle = env.fog;
  ctx.fillRect(0,height*0.55,width,height*0.45);

  // big mountain silhouettes (screen-space)
  function ridge(y, amp, segments, color, alpha, snow){
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(0,height);
    for(let i=0;i<=segments;i++){
      const t = i/segments;
      const x = t*width;
      const noise = Math.sin(t*4)*0.6 + Math.sin(t*13+2)*0.4;
      const yy = y + noise*amp;
      ctx.lineTo(x,yy);
    }
    ctx.lineTo(width,height);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.globalAlpha = alpha;
    ctx.fill();

    // snow highlights on top ridge
    if (snow){
      ctx.globalAlpha = alpha*0.8;
      ctx.beginPath();
      for(let i=0;i<=segments;i++){
        const t = i/segments;
        const x = t*width;
        const noise = Math.sin(t*4)*0.6 + Math.sin(t*13+2)*0.4;
        const yy = y + noise*amp - 10;
        if (i===0) ctx.moveTo(x,yy);
        else ctx.lineTo(x,yy);
      }
      ctx.lineWidth = 6;
      ctx.strokeStyle = env.snow;
      ctx.stroke();
    }
    ctx.restore();
  }

  ridge(height*0.70, 55, 32, env.mountainFar, 0.9, false);
  ridge(height*0.76, 70, 40, env.mountainNear, 1.0, true);
}

// =====================================================
// PATH & LOCAL DETAIL
// =====================================================
function drawPath(mainT){
  const env = envColors(mainT);
  const segments = 80;
  const spanBefore = 0.03;
  const spanAfter  = 0.16; // limited view ahead
  const tStart = Math.max(0, mainT - spanBefore);
  const tEnd   = Math.min(1, mainT + spanAfter);
  const dt = (tEnd - tStart) / segments;

  for (let i=segments-1; i>=0; i--){
    const t0 = tStart + dt*i;
    const t1 = t0 + dt;
    const quad = pathSegmentQuad(t0,t1);
    const proj = quad.map(p=>project(p));
    if (proj.some(p=>p===null)) continue;

    const avgZ = proj.reduce((a,p)=>a+p.z,0)/proj.length;
    let shade = 1 - Math.min(avgZ/450, 0.8);

    function shadeColor(hex, factor){
      const c = parseInt(hex.slice(1),16);
      let r=(c>>16)&255, g=(c>>8)&255, b=c&255;
      r=Math.floor(r*factor); g=Math.floor(g*factor); b=Math.floor(b*factor);
      return `rgb(${r},${g},${b})`;
    }

    // ground under boardwalk
    ctx.beginPath();
    ctx.moveTo(proj[0].x, proj[0].y);
    for(let j=1;j<4;j++) ctx.lineTo(proj[j].x, proj[j].y);
    ctx.closePath();
    ctx.fillStyle = shadeColor(env.ground, 0.45+shade*0.55);
    ctx.fill();

    // inset boardwalk
    const inset = 0.26;
    const insetProj = proj.map((p)=>{
      const cx = (proj[0].x+proj[1].x+proj[2].x+proj[3].x)/4;
      const cy = (proj[0].y+proj[1].y+proj[2].y+proj[3].y)/4;
      return {
        x: cx + (p.x-cx)*(1-inset),
        y: cy + (p.y-cy)*(1-inset)
      };
    });

    // hazard color overlay
    const inHazard = hazard.active && !(t1 < hazard.startT || t0 > hazard.endT);
    ctx.beginPath();
    ctx.moveTo(insetProj[0].x, insetProj[0].y);
    for(let j=1;j<4;j++) ctx.lineTo(insetProj[j].x, insetProj[j].y);
    ctx.closePath();

    if (inHazard){
      let col = "rgba(255,140,70,0.95)";
      if (hazard.type==="blizzard") col = "rgba(230,245,255,0.98)";
      if (hazard.type==="rockfall") col = "rgba(155,130,100,0.98)";
      ctx.fillStyle = col;
    } else {
      ctx.fillStyle = shadeColor(env.path, 0.6+shade*0.4);
    }
    ctx.fill();

    // plank lines for higher detail
    const plankCount = 5;
    ctx.strokeStyle = shadeColor("#2c2c2c", 0.6+shade*0.4);
    ctx.lineWidth = 1;
    for (let k=1;k<plankCount;k++){
      const s = k/plankCount;
      const a = {
        x: insetProj[0].x + (insetProj[3].x-insetProj[0].x)*s,
        y: insetProj[0].y + (insetProj[3].y-insetProj[0].y)*s
      };
      const b = {
        x: insetProj[1].x + (insetProj[2].x-insetProj[1].x)*s,
        y: insetProj[1].y + (insetProj[2].y-insetProj[1].y)*s
      };
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();
    }

    // side edge
    ctx.beginPath();
    ctx.moveTo(insetProj[1].x, insetProj[1].y);
    ctx.lineTo(insetProj[2].x, insetProj[2].y);
    ctx.lineWidth = 2;
    ctx.strokeStyle = shadeColor(env.side, 0.4+shade*0.5);
    ctx.stroke();
  }
}

// hazard particles
function drawHazardParticles(){
  const list = hazard.particles;
  for (const p of list){
    const lifeFrac = p.life / p.maxLife;
    const r = p.size * (0.3 + 0.7*lifeFrac);
    const grad = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r);
    grad.addColorStop(0, p.color1);
    grad.addColorStop(1, p.color2);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(p.x,p.y,r,0,Math.PI*2);
    ctx.fill();
  }

  if (hazard.active && hazard.type === "blizzard"){
    ctx.fillStyle = "rgba(255,255,255,0.15)";
    ctx.fillRect(0,0,width,height);
  }
}

// =====================================================
// CLIMBER DRAWING
// =====================================================
function drawClimber(one, time){
  const basePoint = pathPoint(one.t);
  const ahead = pathPoint(Math.min(1, one.t + 0.01));
  const tangent = norm(sub(ahead, basePoint));
  const up = vec3(0,1,0);
  const side = norm(cross(up,tangent));
  const position = add(basePoint, mul(side, one.sideOffset));

  const p = project(position);
  if (!p) return;

  const baseHeight = 70;
  const size = baseHeight * (1 / (p.z*0.04));
  const headR = size * 0.18;
  const bodyH = size * 0.48;
  const bodyW = size * 0.24;
  const legL  = size * 0.36;
  const armL  = size * 0.34;
  const bob = Math.sin(time*4 + one.bobOffset)* (size*0.04);

  const cx = p.x;
  const cy = p.y - size*0.35 + bob;

  ctx.save();

  // shadow
  const groundPos = project(vec3(position.x,0,position.z));
  if (groundPos){
    ctx.beginPath();
    ctx.ellipse(groundPos.x, groundPos.y, size*0.27, size*0.13, 0, 0, Math.PI*2);
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fill();
  }

  // legs
  ctx.strokeStyle = "#111";
  ctx.lineWidth = size*0.055;
  ctx.lineCap = "round";
  const walk = Math.sin(time*7 + one.bobOffset);

  ctx.beginPath();
  ctx.moveTo(cx, cy + bodyH*0.45);
  ctx.lineTo(cx - size*0.13 + walk*size*0.12,
             cy + bodyH*0.45 + legL);
  ctx.moveTo(cx, cy + bodyH*0.45);
  ctx.lineTo(cx + size*0.13 - walk*size*0.12,
             cy + bodyH*0.45 + legL);
  ctx.stroke();

  // body with gradient
  const bodyTop = cy - bodyH*0.5;
  const bodyGrad = ctx.createLinearGradient(cx,bodyTop,cx,bodyTop+bodyH);
  bodyGrad.addColorStop(0, one.color);
  bodyGrad.addColorStop(1, "rgba(0,0,0,0.4)");
  ctx.fillStyle = bodyGrad;
  ctx.fillRect(cx - bodyW*0.5, bodyTop, bodyW, bodyH);

  // backpack
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  ctx.fillRect(
    cx - bodyW*0.5 - size*0.08,
    bodyTop + bodyH*0.15,
    size*0.16,
    bodyH*0.7
  );

  // arms
  ctx.beginPath();
  ctx.moveTo(cx, bodyTop + bodyH*0.2);
  ctx.lineTo(
    cx - size*0.20 - walk*size*0.18,
    bodyTop + bodyH*0.2 + armL
  );
  ctx.moveTo(cx, bodyTop + bodyH*0.2);
  ctx.lineTo(
    cx + size*0.20 + walk*size*0.18,
    bodyTop + bodyH*0.2 + armL
  );
  ctx.stroke();

  // head
  ctx.beginPath();
  ctx.arc(cx, bodyTop - headR*0.7, headR, 0, Math.PI*2);
  ctx.fillStyle = "#ffd7b0";
  ctx.fill();

  // face highlight
  ctx.beginPath();
  ctx.arc(cx+headR*0.28, bodyTop - headR*0.9, headR*0.35, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.45)";
  ctx.fill();

  ctx.restore();
}

// camera locked just above/behind main climber
function updateCamera(mainClimber){
  const t = mainClimber.t;
  const center = pathPoint(t);
  const ahead = pathPoint(Math.min(1, t + 0.02));
  const tangent = norm(sub(ahead, center));
  const up = vec3(0,1,0);
  const side = norm(cross(tangent, up));

  const backDist = 30;  // close
  const upDist = 24;

  cameraTarget = add(center, mul(up, 16));
  cameraPos = add(
    add(center, mul(tangent, -backDist)),
    mul(up, upDist)
  );
  cameraPos = add(cameraPos, mul(side, 6));
}

// =====================================================
// MAIN LOOP
// =====================================================
let lastTime = performance.now();

function loop(now){
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  const time = now / 1000;

  if (!gameOver){
    gameTime += dt;
  }

  for (const c of climbers){
    if (!gameOver){
      c.t += c.speed * dt;
      if (c.t > 1) c.t = 1;
    }
  }

  const mainClimber = climbers[0];
  updateCamera(mainClimber);
  updateHazard(dt);

  // winner?
  let winner = null;
  for (let i=0;i<climbers.length;i++){
    if (climbers[i].t >= 1){
      winner = i;
      break;
    }
  }
  if (!gameOver && winner !== null){
    gameOver = true;
    eventEl.style.display = "block";
    eventEl.textContent = `üèÅ Player ${winner+1} reached the summit first! (Send Money Gun to restart)`;
  }

  const avgT = Math.min(1, mainClimber.t + 0.1);

  drawMountains(avgT);

  // shake
  ctx.save();
  if (shakeIntensity > 0){
    const sx = (Math.random()*2-1) * shakeIntensity;
    const sy = (Math.random()*2-1) * shakeIntensity;
    ctx.translate(sx, sy);
  }

  drawPath(mainClimber.t);

  // draw climbers back-to-front
  const sorted = [...climbers].sort((a,b)=>{
    const pa = project(pathPoint(a.t));
    const pb = project(pathPoint(b.t));
    return (pb?.z||0) - (pa?.z||0);
  });
  for (const c of sorted){
    drawClimber(c, time);
  }

  ctx.restore();
  drawHazardParticles();

  // HUD status (big enough for TikTok viewers)
  const mins = Math.floor(gameTime / 60);
  const secs = Math.floor(gameTime % 60).toString().padStart(2,"0");
  const mainPct = Math.round(mainClimber.t * 100);
  const nextIn = Math.max(0, Math.ceil(nextHazardAt - gameTime));
  statusEl.textContent =
    `‚è± ${mins}:${secs} / 30:00 ¬∑ üßç Players: ${climbers.length} ¬∑ Main climber: ${mainPct}% ¬∑ Next test in ~${nextIn}s`;

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
